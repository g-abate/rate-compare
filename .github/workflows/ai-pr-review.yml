name: AI PR Review 

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]

permissions:
  contents: read
  pull-requests: write
  statuses: write

env:
  # Change to APPROVE / REQUEST_CHANGES / COMMENT
  REVIEW_EVENT: COMMENT
  # Configure which CLI to run for the review. Default is amp execute mode.
  REVIEW_CLI_BIN: amp
  REVIEW_CLI_ARGS: -x
  # WordPress Plugin AI Review Prompt
  SYSTEM_PROMPT: |
    You are reviewing a WordPress plugin pull request. Focus on:
    
    WordPress Standards:
    - Follow WordPress PHP Coding Standards
    - Use proper WordPress hooks, actions, and filters
    - Implement proper sanitization and escaping
    - Check for nonce verification and capability checks
    - Ensure proper internationalization with text domains
    
    Security (Critical):
    - Input validation and sanitization
    - Output escaping (esc_html, esc_attr, esc_url)
    - SQL injection prevention (prepared statements)
    - XSS prevention
    - CSRF protection (nonces)
    - File upload validation
    - User capability checks
    
    Plugin Architecture:
    - Proper class structure and naming conventions
    - Singleton pattern for main plugin class
    - Proper activation/deactivation hooks
    - Database operations using $wpdb
    - Transient caching usage
    - REST API endpoint security
    
    Performance:
    - Database query optimization
    - Caching strategies
    - Asset loading optimization
    - Memory usage considerations
    
    Code Quality:
    - Clear function and variable names
    - Proper documentation (DocBlocks)
    - Error handling
    - Test coverage considerations
    
    Be concise, constructive, and specific. Group related issues together.
    Prioritize security and WordPress standards compliance.

jobs:
  review:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    concurrency:
      group: ai-pr-review-${{ github.event.pull_request.number }}
      cancel-in-progress: true

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Verify tools
        run: |
          node -v
          npm -v
          jq --version
          curl --version

      - name: Setup AI API access
        run: |
          set -euo pipefail
          echo "Setting up AI API access..."
          
          # Check for API keys
          export AMP_API_KEY="${AMP_API_KEY:-${AI_API_KEY:-}}"
          export ANTHROPIC_API_KEY="${ANTHROPIC_API_KEY:-${AI_API_KEY:-}}"
          
          if [ -n "$AMP_API_KEY" ]; then
            echo "AMP_API_KEY found, will use Amp API"
            echo "AMP_API_KEY" > ai_provider.txt
          elif [ -n "$ANTHROPIC_API_KEY" ]; then
            echo "ANTHROPIC_API_KEY found, will use Claude API"
            echo "ANTHROPIC_API_KEY" > ai_provider.txt
          else
            echo "No API key found, will use fallback"
            echo "FALLBACK" > ai_provider.txt
          fi


      - name: Gather PR context
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          # Set for this step and export for later steps
          PR="${{ github.event.pull_request.number }}"
          SHA="${{ github.event.pull_request.head.sha }}"
          echo "PR=$PR" >> "$GITHUB_ENV"
          echo "SHA=$SHA" >> "$GITHUB_ENV"

          # Use explicit repo + PR number in detached HEAD context
          gh pr view "$PR" --repo "${{ github.repository }}" --json number,title,body,author,baseRefName,headRefName,url > pr.json
          gh pr diff "$PR" --repo "${{ github.repository }}" --patch > diff.patch

      - name: Run AI review
        env:
          AI_API_KEY: ${{ secrets.AI_API_KEY }}
          AMP_API_KEY: ${{ secrets.AMP_API_KEY }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          set -euo pipefail
          # Map AI_API_KEY to vendor-specific vars when missing
          export AMP_API_KEY="${AMP_API_KEY:-${AI_API_KEY:-}}"
          export ANTHROPIC_API_KEY="${ANTHROPIC_API_KEY:-${AI_API_KEY:-}}"
          # Mask API keys in logs just in case
          if [ -n "${AI_API_KEY:-}" ]; then echo "::add-mask::${AI_API_KEY}"; fi
          if [ -n "${AMP_API_KEY:-}" ]; then echo "::add-mask::${AMP_API_KEY}"; fi
          if [ -n "${ANTHROPIC_API_KEY:-}" ]; then echo "::add-mask::${ANTHROPIC_API_KEY}"; fi

          # Compose the instruction sent to cli (XML output with example)
          INSTRUCTION=$(cat <<'EOF'
          You are performing a single-pass human-style PR review.

          Inputs:
          - You will receive a unified diff (the PR patch) via stdin.
          - Comment only on added lines; avoid spam.

          Output format - XML with this exact structure:

          <review>
            <summary>Overall assessment in 2-3 sentences. Focus on correctness, security, and readability.</summary>
            <comments>
              <comment>
                <file>path/to/file.ext</file>
                <line>123</line>
                <body>Your comment about this specific line</body>
              </comment>
              <!-- Add more comment blocks as needed, or leave empty if no specific issues -->
              <!-- IMPORTANT: Use line numbers from the diff context, not absolute file line numbers -->
            </comments>
            <status>
              <state>success</state> <!-- or "failure" if issues need fixing before merge -->
              <description>Brief reason (under 120 chars)</description>
            </status>
          </review>

          Example good response:
          <review>
            <summary>This PR adds user authentication with proper input validation. The implementation looks solid overall with good error handling.</summary>
            <comments>
              <comment>
                <file>auth.js</file>
                <line>45</line>
                <body>Consider using bcrypt.compare() instead of === for password comparison to prevent timing attacks.</body>
              </comment>
            </comments>
            <status>
              <state>success</state>
              <description>LGTM with minor security suggestion</description>
            </status>
          </review>
          EOF
          )

          # Run AI review using direct API calls
          echo "Running AI review..."
          echo "Diff size: $(wc -c < diff.patch) bytes"
          
          # Read the AI provider
          AI_PROVIDER=$(cat ai_provider.txt)
          echo "Using AI provider: $AI_PROVIDER"
          
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Attempt $((RETRY_COUNT + 1)) of $MAX_RETRIES..."
            
            if [ "$AI_PROVIDER" = "AMP_API_KEY" ] && [ -n "$AMP_API_KEY" ]; then
              echo "Using Amp API..."
              # Use Amp API directly
              curl -s -X POST "https://api.ampcode.com/v1/chat/completions" \
                -H "Authorization: Bearer $AMP_API_KEY" \
                -H "Content-Type: application/json" \
                -d "{
                  \"model\": \"gpt-4\",
                  \"messages\": [
                    {\"role\": \"system\", \"content\": \"${SYSTEM_PROMPT}\n\n${INSTRUCTION}\"},
                    {\"role\": \"user\", \"content\": \"$(cat diff.patch | sed 's/"/\\"/g' | tr '\n' '\\n')\"}
                  ],
                  \"max_tokens\": 4000,
                  \"temperature\": 0.1
                }" > ai_output_raw.json
              
              # Extract content from JSON response
              if command -v jq >/dev/null 2>&1; then
                jq -r '.choices[0].message.content' ai_output_raw.json > ai_output.xml
              else
                # Fallback JSON parsing
                grep -o '"content":"[^"]*"' ai_output_raw.json | sed 's/"content":"//g' | sed 's/"$//g' > ai_output.xml
              fi
              
            elif [ "$AI_PROVIDER" = "ANTHROPIC_API_KEY" ] && [ -n "$ANTHROPIC_API_KEY" ]; then
              echo "Using Claude API..."
              # Use Claude API directly
              curl -s -X POST "https://api.anthropic.com/v1/messages" \
                -H "x-api-key: $ANTHROPIC_API_KEY" \
                -H "Content-Type: application/json" \
                -H "anthropic-version: 2023-06-01" \
                -d "{
                  \"model\": \"claude-3-sonnet-20240229\",
                  \"max_tokens\": 4000,
                  \"system\": \"${SYSTEM_PROMPT}\n\n${INSTRUCTION}\",
                  \"messages\": [
                    {\"role\": \"user\", \"content\": \"$(cat diff.patch | sed 's/"/\\"/g' | tr '\n' '\\n')\"}
                  ]
                }" > ai_output_raw.json
              
              # Extract content from JSON response
              if command -v jq >/dev/null 2>&1; then
                jq -r '.content[0].text' ai_output_raw.json > ai_output.xml
              else
                # Fallback JSON parsing
                grep -o '"text":"[^"]*"' ai_output_raw.json | sed 's/"text":"//g' | sed 's/"$//g' > ai_output.xml
              fi
              
            else
              echo "No valid API key found, using fallback response"
              cat > ai_output.xml <<'FALLBACK'
          <review>
            <summary>AI review unavailable - no API key configured. Please set AMP_API_KEY or ANTHROPIC_API_KEY secret.</summary>
            <comments></comments>
            <status>
              <state>success</state>
              <description>Fallback review - API key needed</description>
            </status>
          </review>
          FALLBACK
            fi
            
            # Check if output contains valid XML with required elements
            if grep -q "<review>" ai_output.xml && grep -q "<summary>" ai_output.xml && grep -q "</review>" ai_output.xml; then
              echo "Valid XML review received"
              break
            else
              echo "Invalid or empty XML received, retrying..."
              RETRY_COUNT=$((RETRY_COUNT + 1))
            fi
            
            # Add delay between retries
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              echo "Waiting 5 seconds before retry..."
              sleep 5
            fi
          done
          
          # If all retries failed, create fallback response
          if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
            echo "All 5 retry attempts failed, creating fallback response"
            cat > ai_output.xml <<'FALLBACK'
          <review>
            <summary>AI review failed after multiple attempts.</summary>
            <comments></comments>
            <status>
              <state>success</state>
              <description>AI Review completed with fallback</description>
            </status>
          </review>
          FALLBACK
          fi

          echo "AI review completed"
          echo "--- XML Output ---"
          cat ai_output.xml
          echo -e "\n--- End XML Output ---"

          # Extract sections using Node.js for reliable parsing
          echo "Using Node.js for XML parsing..."
          node -e "
          const fs = require('fs');
          try {
            const xmlText = fs.readFileSync('ai_output.xml', 'utf8');
            
            // Extract summary
            const summaryMatch = xmlText.match(/<summary>([\s\S]*?)<\/summary>/);
            const summary = summaryMatch ? summaryMatch[1].trim() : 'No summary found';
            fs.writeFileSync('summary.txt', summary);
            
            // Extract state  
            const stateMatch = xmlText.match(/<state>([\s\S]*?)<\/state>/);
            const state = stateMatch ? stateMatch[1].trim() : 'success';
            fs.writeFileSync('state.txt', state);
            
            // Extract description
            const descMatch = xmlText.match(/<description>([\s\S]*?)<\/description>/);
            const desc = descMatch ? descMatch[1].trim() : 'AI Review completed';
            fs.writeFileSync('description.txt', desc);
            
          } catch (error) {
            fs.writeFileSync('summary.txt', 'XML parsing failed');
            fs.writeFileSync('state.txt', 'success');
            fs.writeFileSync('description.txt', 'AI Review completed');
          }
          "

          # Convert summary to markdown for review body
          echo "## Summary" > review.md
          cat summary.txt >> review.md

          # Extract inline comments for GitHub API
          echo "[]" > comments.json
          if grep -q "<comment>" ai_output.xml; then
            echo "Processing inline comments for GitHub API..."
            
            # Use absolute line numbers with side (much more reliable than positions)
            echo "Extracting comments with absolute line numbers..."
            
            node -e "
            const fs = require('fs');
            
            try {
              // Read and parse XML comments
              const xmlText = fs.readFileSync('ai_output.xml', 'utf8');
              const comments = [];
              
              // Extract comment blocks
              const commentBlocks = xmlText.match(/<comment>[\s\S]*?<\/comment>/g) || [];
              
              for (const block of commentBlocks) {
                const fileMatch = block.match(/<file>(.*?)<\/file>/);
                const lineMatch = block.match(/<line>(.*?)<\/line>/);
                const bodyMatch = block.match(/<body>(.*?)<\/body>/);
                
                if (fileMatch && lineMatch && bodyMatch) {
                  const file = fileMatch[1].trim();
                  const line = parseInt(lineMatch[1].trim());
                  const body = bodyMatch[1].trim();
                  
                  // Use absolute line number with side (much more reliable than position)
                  comments.push({
                    path: file,
                    line: line,
                    side: 'RIGHT',
                    body: body.replace(/\"/g, '\\\"')
                  });
                }
              }
              
              // Write result
              fs.writeFileSync('comments.json', JSON.stringify(comments));
              
            } catch (error) {
              // Fallback to empty array
              fs.writeFileSync('comments.json', '[]');
            }
            "
            
            echo "Generated comments JSON:"
            cat comments.json
          fi

          # Create status JSON
          STATE=$(cat state.txt)
          DESC=$(cat description.txt)
          echo "{\"state\":\"$STATE\",\"description\":\"$DESC\"}" > status.json

      - name: Post PR review
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          # Build review payload with body + comments array
          jq -n \
            --arg event "${REVIEW_EVENT}" \
            --arg body "$(cat review.md)" \
            --argjson comments "$(cat comments.json)" \
            '{ event: $event, body: $body, comments: $comments }' > review_payload.json

          # Post the review
          gh api \
            -X POST \
            -H "Accept: application/vnd.github+json" \
            "repos/${{ github.repository }}/pulls/$PR/reviews" \
            --input review_payload.json

      - name: Set commit status from AI StatusJSON
        if: always()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          # Guard: create a default status if missing
          if [ ! -f status.json ]; then
            echo '{"state":"success","description":"AI Review completed"}' > status.json
          fi
          STATE=$(jq -r '.state // "success"' status.json)
          DESC=$(jq -r '.description // "AI Review completed"' status.json)
          SHA="${{ github.event.pull_request.head.sha }}"
          gh api \
            -X POST \
            repos/${{ github.repository }}/statuses/${SHA} \
            -f state="$STATE" \
            -f context="AI PR Review" \
            -f description="$DESC"
